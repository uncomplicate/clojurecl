<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>uncomplicate.clojurecl.utils documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Clojurecl</span> <span class="project-version">0.6.6-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uncomplicate</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojurecl</span></div></div></li><li class="depth-3 branch"><a href="uncomplicate.clojurecl.constants.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constants</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.clojurecl.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.clojurecl.info.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>info</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.clojurecl.legacy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>legacy</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.clojurecl.toolbox.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>toolbox</span></div></a></li><li class="depth-3 current"><a href="uncomplicate.clojurecl.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="uncomplicate.clojurecl.utils.html#var-clean-buffer"><div class="inner"><span>clean-buffer</span></div></a></li><li class="depth-1"><a href="uncomplicate.clojurecl.utils.html#var-error"><div class="inner"><span>error</span></div></a></li><li class="depth-1"><a href="uncomplicate.clojurecl.utils.html#var-mask"><div class="inner"><span>mask</span></div></a></li><li class="depth-1"><a href="uncomplicate.clojurecl.utils.html#var-maybe"><div class="inner"><span>maybe</span></div></a></li><li class="depth-1"><a href="uncomplicate.clojurecl.utils.html#var-unmask"><div class="inner"><span>unmask</span></div></a></li><li class="depth-1"><a href="uncomplicate.clojurecl.utils.html#var-unmask1"><div class="inner"><span>unmask1</span></div></a></li><li class="depth-1"><a href="uncomplicate.clojurecl.utils.html#var-with-check"><div class="inner"><span>with-check</span></div></a></li><li class="depth-1"><a href="uncomplicate.clojurecl.utils.html#var-with-check-arr"><div class="inner"><span>with-check-arr</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">uncomplicate.clojurecl.utils</h1><div class="doc"><div class="markdown"><p>Utility functions used as helpers in other ClojureCL namespaces. The user of the ClojureCL library would probably not need to use any of the functions defined here.</p></div></div><div class="public anchor" id="var-clean-buffer"><h3>clean-buffer</h3><div class="usage"><code>(clean-buffer buffer)</code></div><div class="doc"><div class="markdown"><p>Cleans the direct byte buffer using JVMâ€™s cleaner, and releases the memory that resides outside JVM, wihich might otherwise linger very long until garbage collected. See the Java documentation for DirectByteBuffer for more info.</p></div></div></div><div class="public anchor" id="var-error"><h3>error</h3><div class="usage"><code>(error err-code details)</code><code>(error err-code)</code></div><div class="doc"><div class="markdown"><p>Converts an OpenCL error code to an <a href="http://clojuredocs.org/clojure.core/ex-info">ExceptionInfo</a> with richer, user-friendly information.</p>
<p>Accepts a long <code>err-code</code> that should be one of the codes defined in OpenCL standard, and an optional <code>details</code> argument that could be anything that you think is informative.</p>
<p>See the available codes in the source of <a href="uncomplicate.clojurecl.constants.html#var-dec-error">constants/dec-error</a>. Also see the discussion about <a href="http://streamcomputing.eu/blog/2013-04-28/opencl-1-2-error-codes/">OpenCL error codes</a>.</p>
<p>Examples:</p>
<pre><code>(error 0) =&gt; an ExceptionInfo instance
(error -5 {:comment "Why here?""}) =&gt; an ExceptionInfo instance
</code></pre></div></div></div><div class="public anchor" id="var-mask"><h3>mask</h3><div class="usage"><code>(mask table flag1 flag2 flags)</code><code>(mask table flag flags)</code><code>(mask table flags)</code></div><div class="doc"><div class="markdown"><p>Converts keywords to a bitfield mask.</p>
<p>Given one or more keyword <code>flag</code>s, creates a long bitmask that can be consumed by JOCL functions. Needs a hashmap <code>table</code> that contains possible long mappings, 0-2 keywords, and a (possibly empty) list of additional keywords. If called with <code>nil</code> table or an unknown keyword, throws <code>Illegalargumentexception</code>. The inverse function is <a href="uncomplicate.clojurecl.utils.html#var-unmask">unmask</a>.</p>
<p>Examples:</p>
<pre><code>(mask {:a 1 :b 2 :c 4} [:a :c]) =&gt; 5
(mask {:a 1 :b 2 :c 4} :a [:c]) =&gt; 5
(mask {:a 1 :b 2 :c 4} :a :c []) =&gt; 5
</code></pre></div></div></div><div class="public anchor" id="var-maybe"><h3>maybe</h3><h4 class="type">macro</h4><div class="usage"><code>(maybe form)</code></div><div class="doc"><div class="markdown"><p>Evaluates form in try/catch block; if an OpenCL-related exception is caught, substitutes the result with the <a href="http://clojuredocs.org/clojure.core/ex-info">ExceptionInfo</a> object. Non-OpenCL exceptions are rethrown. Useful when we do not want to let a minor OpenCL error due to a driver incompatibility with the standard or an unimplemented feature in the actual driver crash the application. An <a href="http://clojuredocs.org/clojure.core/ex-info">ExceptionInfo</a> object will be put in the place of the expected result.</p></div></div></div><div class="public anchor" id="var-unmask"><h3>unmask</h3><div class="usage"><code>(unmask table mask)</code></div><div class="doc"><div class="markdown"><p>Converts a bitfield <code>mask</code> to keywords.</p>
<p>Given a mapping <code>table</code> and a bitfield <code>mask</code>, returns a lazy sequence with decoded keyword flags contained in the bitmask. The reverse function is <a href="uncomplicate.clojurecl.utils.html#var-mask">mask</a>.</p>
<p>Examples:</p>
<pre><code>(unmask {:a 1 :b 2 :c 4} 5) =&gt;  '(:a :c)
</code></pre></div></div></div><div class="public anchor" id="var-unmask1"><h3>unmask1</h3><div class="usage"><code>(unmask1 table mask)</code></div><div class="doc"><div class="markdown"><p>Converts a bitfield <code>mask</code> to one keyword.</p>
<p>Given a mapping <code>table</code> and a bitfield <code>mask</code>, returns the first decoded keyword that is contained in the bitmask. This is useful when we know that just one of the values in the table fits the bitmask, so the result of <a href="uncomplicate.clojurecl.utils.html#var-unmask">unmask</a> would contain one element anyway. The reverse function is <a href="uncomplicate.clojurecl.utils.html#var-mask">mask</a>.</p>
<p>Examples:</p>
<pre><code>(unmask1 {:a 1 :b 2 :c 4} 2) =&gt; :b
</code></pre></div></div></div><div class="public anchor" id="var-with-check"><h3>with-check</h3><h4 class="type">macro</h4><div class="usage"><code>(with-check error-fn err-code form)</code><code>(with-check err-code form)</code></div><div class="doc"><div class="markdown"><p>Evaluates <code>form</code> if <code>err-code</code> is not zero (<code>CL_SUCCESS</code>), otherwise throws an appropriate <code>ExceptionInfo</code> with decoded informative details. It helps fith JOCL methods that return error codes directly, while returning computation results through side-effects in arguments.</p>
<p>Example:</p>
<pre><code>(with-check (some-jocl-call-that-returns-error-code) result)
</code></pre></div></div></div><div class="public anchor" id="var-with-check-arr"><h3>with-check-arr</h3><h4 class="type">macro</h4><div class="usage"><code>(with-check-arr err-code form)</code></div><div class="doc"><div class="markdown"><p>Evaluates <code>form</code> if the integer in the <code>err-code</code> primitive int array is <code>0</code>, Otherwise throws an exception corresponding to the error code. Similar to <a href="uncomplicate.clojurecl.utils.html#var-with-check">with-check</a>, but with the error code being held in an array instead of being a primitive number. It helps with JOCL methods that return results directly, and signal errors through side-effects in a primitive array argument.</p>
<pre><code>(let [err (int-array 1)
      res (some-jocl-call err)]
   (with-checl-arr err res))
</code></pre></div></div></div></div></body></html>